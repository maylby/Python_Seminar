# Знакомство с языком Python (семинары)
# Урок 7. Функции высшего порядка
# https://gb.ru/lessons/391158


# 01:13:30
"""
(разбор ДЗ-06, Александр Верзун)

Задача 30: 
Заполните массив элементами арифметической прогрессии. 
Её первый элемент, разность и количество
элементов нужно ввести с клавиатуры. 
Формула для получения n-го члена прогрессии: 
an = a1 + (n - 1) * d

Каждое число вводится с новой строки.
"""
# Ввод: 7 2 5 # 7 - число, 2 - шаг, 5 - количество
# Вывод: 7 9 11 13 15

"""
Решение

Вариант 1
"""

# num = int(input('Input number: ')) 
# step = int(input('Input step: '))
# count = int(input('Input count: '))

# my_list = [num]
# for i in range(step, count + 1): 
# 	my_list.append(num + (i - 1) * step)

# print(num, step, count)
# print(*my_list)

'''
Вариант 2 (генератор списков)
'''
# my_list = [num + i * step for i in range(count)]
# print(my_list)


"""
Задача 32:

Задать произвольные границы диапазона значений (min, max) и  
определить индексы элементов массива (списка),
значения которых лежат в заданном диапазоне (?),
т.е. не меньше заданного минимума 
и не больше заданного максимума.
"""

# Ввод: 
# [-5, 9, 0, 3, -1, -2, 1,
# 4, -2, 10, 2, 0, -9, 8, 
# 10, -9, 0, -5, -5, 7]

# Вывод: [1, 9, 13, 14, 19]

"""
Решение

Вариант 1
"""
# #	         1                          9            13  14                19
# list1 = [-5, 9, 0, 3, -1, -2, 1, 4, -2, 10, 2, 0, -9, 8, 10, -9, 0, -5, -5, 7]
# #	      0  1  2  3   4   5  6  7   8  9  10  11 12  13 14  15  16 17  18  19

# min = int(input('min: '))
# max = int(input('max: '))

# def search(arr): # 'arr' - пустой список для передачи значений 'list1'
# 	result = []
# 	for i in range(len(arr)): 
# 		if min <= list1[i] <= max: # допустимая форма записи
# 			result.append(i) # добавление индексов элементов
# 	return result 

# print('Ввод: ', list1)
# print('Вывод:', search(list1)) 



# 00:17:10

"""
Задача про холодильники 
(чат семинара)

Программа должна вывести номера зараженных холодильников через пробел. 
Если таких холодильников нет, ничего выводить не нужно.

Формат входных данных
В первой строке подаётся число 'n'.
'n' – количество холодильников. 
В последующих n-строках вводятся строки, 
содержащие латинские строчные буквы и цифры, 
в каждой строке от 5 до 100 символов.

два способа решения через списки и через условие (?)
"""

# Sample Input 1: 6

# 222anton456
# a1n1t1o1n1
# 0000a0000n00t00000o000000n
# gylfole
# richard
# ant0n

# Sample Output 1:
# 1 2 3


# Sample Input 2: 9

# osfjwoiergwoignaewpjofwoeijfnwfonewfoignewtowenffnoeiwowjfninoiwfen
# anton
# aoooooooooontooooo
# elelelelelelelelelel
# ntoneeee
# tonee
# 253235235a5323352n25235352t253523523235oo235523523523n
# antoooooooooooooooooooooooooooooooooooooooooooooooooooon
# unton

# Sample Output 2: 
# 1 2 7 8

"""
Решение

Вариант 1 (Александр Верзун)
"""
# fridge = ['222anton456',
# 	  'a1n1t1o1n1',
# 	  '0000a0000n00t00000o000000n',
# 	  'gylfole',
# 	  'richard',
# 	  'ant0n']

# virus = 'anton'

# for k in range(len(fridge)): # перебор всего списка кодов 'fridge'
# 	j = 0 # стартовое значение переменной индекса вируса (virus)
# 	for i in fridge[k]:
# 		if i.lower() == virus[j]: # если буква слова и вируса совпадают,
# 			j += 1		  # перейти к следующей букве
# 			if j == 5: # Какой записью заменить число? Этой (?) virus[j + 1] 
# 				   # если все значения вируса проверены, то
# 				print(k + 1, end =' ')  # перейти к следующему коду списка
# 				break 			# завершить по окончанию списка


# 00:20:30
"""
Вариант 2 (Андрей Лопатько)
"""

# def antivirus(str1, exmpl): # <- функция антивирус
# 	index_01 = str1.find(exmpl[0])
# 	if index_01 < 0: return False # если первого символа нет, завершить проверку
# 				      # что будет, если записать index_01[i] < 0?
# 	else: 
# 		 res = str1[index_01] # в переменной (res) записываем вирус
	
# 	for i in range(1, len(exmpl)):
# 		# print(index[i])
# 		index_02 = str1[index_01 + 1:].find(exmpl[i]) + index_01 + 1
# 						# метод 'find()' возвращает идекс буквы,
# 						# если не находит возвращает -1
# 		# print(str1[index_0], index_0)
# 		if index_02 > index_01: # условие на случай, когда буква не будет найдена,
# 					# т.е. index_02 будет идентифицирован как -1							# и будет меньше любого index_01, 
# 					# что противоречит условию (index_02 > index_01)
# 			res += str1[index_02] # добавление найденного элемента
# 			index_01 = index_02 # переприсваиваем (?) значение и
# 					    # начинаем заново проверять остаток строки
# 	# print(res)
# 	# if res == exmpl: return 'Заражено!'
# 	# else: return 'Не заражено'
# 	return res == exmpl # сравнение результата с исходником
# 			    # если совпадает, то возвращает: 'Заражено!'
# 			    # иначе, возрат - 'Не заражено'

# exsample = 'anton' # <- сигнатура
# 		   # при необходимости можно заменить любой другой

# str_arr = [
# 	   '222anton456',
# 	   'a1n1t1o1n1',
# 	   '0000a0000n00t00000o000000n',
# 	   'gylfole',
# 	   'richard',
# 	   'ant0n']

# for i in range(len(str_arr)): # реализация:
# 	if antivirus(str_arr[i], exsample):
# 		print(i + 1, end = ' ')



# 00:29:30

''' Определить дружественная рекурсия или нет '''
"""
Два различных натуральных числа n и m называются дружественными, 
если сумма делителей числа n (включая 1, но исключая само n) 
равна числу m и наоборот.

Решение

Вариант 1 (семинар 6)
"""
# n = 300
# dict01 = {}
# for i in range(n):
# 	sum = 0
# 	for j in range(1, i // 2 + 1): 
# 		if i % j == 0:
# 			sum += j
# 	dict01[i] = sum

# print(dict01)
# print(len(dict01))


"""
Вариант 2 (Андрей Лопатько)
"""
# n = 300
# res = {}
# for x, y in res.items(): # 'item()' возвращает копию списка, 
#                          # пар ключ-значение словаря
# 	if y < n:
# 		if res[y] == x and x != y and x < y:
# 			print(x, y)



# 00:40:00
"""
Разбор решения задачи (???)
"""