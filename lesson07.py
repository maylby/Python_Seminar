# Знакомство с языком Python (семинары)
# Урок 7. Функции высшего порядка
# https://gb.ru/lessons/391158


# 01:13:30
"""
(разбор ДЗ-06, Александр Верзун)

Задача 30: 
Заполните массив элементами арифметической прогрессии. 
Её первый элемент, разность и количество
элементов нужно ввести с клавиатуры. 
Формула для получения n-го члена прогрессии: 
an = a1 + (n - 1) * d

Каждое число вводится с новой строки.
"""
# Ввод: 7 2 5 # 7 - число, 2 - шаг, 5 - количество
# Вывод: 7 9 11 13 15

"""
Решение

Вариант 1
"""

# num = int(input('Input number: ')) 
# step = int(input('Input step: '))
# count = int(input('Input count: '))

# my_list = [num]
# for i in range(step, count + 1): 
# 	my_list.append(num + (i - 1) * step)

# print(num, step, count)
# print(*my_list)

'''
Вариант 2 (генератор списков)
'''
# my_list = [num + i * step for i in range(count)]
# print(my_list)


"""
Задача 32:

Задать произвольные границы диапазона значений (min, max) и  
определить индексы элементов массива (списка),
значения которых лежат в заданном диапазоне (?),
т.е. не меньше заданного минимума 
и не больше заданного максимума.
"""

# Ввод: 
# [-5, 9, 0, 3, -1, -2, 1,
# 4, -2, 10, 2, 0, -9, 8, 
# 10, -9, 0, -5, -5, 7]

# Вывод: [1, 9, 13, 14, 19]

"""
Решение

Вариант 1
"""
# #	         1                          9            13  14                19
# list1 = [-5, 9, 0, 3, -1, -2, 1, 4, -2, 10, 2, 0, -9, 8, 10, -9, 0, -5, -5, 7]
# #	      0  1  2  3   4   5  6  7   8  9  10  11 12  13 14  15  16 17  18  19

# min = int(input('min: '))
# max = int(input('max: '))

# def search(arr): # 'arr' - пустой список для передачи значений 'list1'
# 	result = []
# 	for i in range(len(arr)): 
# 		if min <= list1[i] <= max: # допустимая форма записи
# 			result.append(i) # добавление индексов элементов
# 	return result 

# print('Ввод: ', list1)
# print('Вывод:', search(list1)) 



# 00:17:10

"""
Задача про холодильники 
(чат семинара)

Программа должна вывести номера зараженных холодильников через пробел. 
Если таких холодильников нет, ничего выводить не нужно.

Формат входных данных
В первой строке подаётся число 'n'.
'n' – количество холодильников. 
В последующих n-строках вводятся строки, 
содержащие латинские строчные буквы и цифры, 
в каждой строке от 5 до 100 символов.

два способа решения через списки и через условие (?)
"""

# Sample Input 1: 6

# 222anton456
# a1n1t1o1n1
# 0000a0000n00t00000o000000n
# gylfole
# richard
# ant0n

# Sample Output 1:
# 1 2 3


# Sample Input 2: 9

# osfjwoiergwoignaewpjofwoeijfnwfonewfoignewtowenffnoeiwowjfninoiwfen
# anton
# aoooooooooontooooo
# elelelelelelelelelel
# ntoneeee
# tonee
# 253235235a5323352n25235352t253523523235oo235523523523n
# antoooooooooooooooooooooooooooooooooooooooooooooooooooon
# unton

# Sample Output 2: 
# 1 2 7 8

"""
Решение

Вариант 1 (Александр Верзун)
"""
# fridge = ['222anton456',
# 	  'a1n1t1o1n1',
# 	  '0000a0000n00t00000o000000n',
# 	  'gylfole',
# 	  'richard',
# 	  'ant0n']

# virus = 'anton'

# for k in range(len(fridge)): # перебор всего списка кодов 'fridge'
# 	j = 0 # стартовое значение переменной индекса вируса (virus)
# 	for i in fridge[k]:
# 		if i.lower() == virus[j]: # если буква слова и вируса совпадают,
# 			j += 1		  # перейти к следующей букве
# 			if j == 5: # Какой записью заменить число? Этой (?) virus[j + 1] 
# 				   # если все значения вируса проверены, то
# 				print(k + 1, end =' ')  # перейти к следующему коду списка
# 				break 			# завершить по окончанию списка


# 00:20:30
"""
Вариант 2 (Андрей Лопатько)
"""

# def antivirus(str1, exmpl): # <- функция антивирус
# 	index_01 = str1.find(exmpl[0])
# 	if index_01 < 0: return False # если первого символа нет, завершить проверку
# 				      # что будет, если записать index_01[i] < 0?
# 	else: 
# 		 res = str1[index_01] # в переменной (res) записываем вирус
	
# 	for i in range(1, len(exmpl)):
# 		# print(index[i])
# 		index_02 = str1[index_01 + 1:].find(exmpl[i]) + index_01 + 1
# 						# метод 'find()' возвращает идекс буквы,
# 						# если не находит возвращает -1
# 		# print(str1[index_0], index_0)
# 		if index_02 > index_01: # условие на случай, когда буква не будет найдена,
# 					# т.е. index_02 будет идентифицирован как -1							# и будет меньше любого index_01, 
# 					# что противоречит условию (index_02 > index_01)
# 			res += str1[index_02] # добавление найденного элемента
# 			index_01 = index_02 # переприсваиваем (?) значение и
# 					    # начинаем заново проверять остаток строки
# 	# print(res)
# 	# if res == exmpl: return 'Заражено!'
# 	# else: return 'Не заражено'
# 	return res == exmpl # сравнение результата с исходником
# 			    # если совпадает, то возвращает: 'Заражено!'
# 			    # иначе, возрат - 'Не заражено'

# exsample = 'anton' # <- сигнатура
# 		   # при необходимости можно заменить любой другой

# str_arr = [
# 	   '222anton456',
# 	   'a1n1t1o1n1',
# 	   '0000a0000n00t00000o000000n',
# 	   'gylfole',
# 	   'richard',
# 	   'ant0n']

# for i in range(len(str_arr)): # реализация:
# 	if antivirus(str_arr[i], exsample):
# 		print(i + 1, end = ' ')



# 00:29:30

''' Определить дружественная рекурсия или нет '''
"""
Два различных натуральных числа n и m называются дружественными, 
если сумма делителей числа n (включая 1, но исключая само n) 
равна числу m и наоборот.

Решение

Вариант 1 (семинар 6)
"""
# n = 300
# dict01 = {}
# for i in range(n):
# 	sum = 0
# 	for j in range(1, i // 2 + 1): 
# 		if i % j == 0:
# 			sum += j
# 	dict01[i] = sum

# print(dict01)
# print(len(dict01))


"""
Вариант 2 (Андрей Лопатько)
"""
# n = 300
# res = {}
# for x, y in res.items(): # 'item()' возвращает копию списка, 
#                          # пар ключ-значение словаря
# 	if y < n:
# 		if res[y] == x and x != y and x < y:
# 			print(x, y)



# 00:40:00
"""
Повтор пройденного (функции и аргументы)

Функция 
"""
def f(a):
    return a
print(f(5)) # 5


""" 
Lambda-функция 
"""
f1 = lambda a1: a1  # lambda-функция - краткая запись стандартной (см.выше)
                    # до двоеточия 'a1' - это аргумент, 
                    # после двоеточия 'a1' - это 'return'
print(f1(6)) # 6
print((lambda a2: a2)(7)) # 7


""" 
Функция 'map' 
"""
num = "1 2 3 5 6 7 9 0".split()
print(num) # ['1', '2', '3', '5', '6', '7', '9', '0']


num1 = list(map(int, num))  # перевод результата работы функции "split()" в стандартный список.
                            # аргументы внутри скобок функции "map()":
                            # 1) "int" - требуемый тип данных;
                            # 2) "num" - вызываемая переменная (агумент).
print(num1) # [1, 2, 3, 5, 6, 7, 9, 0]


"""
Lambda-функция в 'map'

Функция Lambda не требует вызова, так как 
предназначена, исключительно, для строки, в которой прописана 
"""

num2 = list(map(lambda x: int(x) * 2, num)) # в lambda-функции после двоеточия, т.е. в 'return',
                                            # можно написать, что угодно, например: 'int(x) * 2',
                                            # увелечив значение каждого элемента в 2 раза
print(num2) # [2, 4, 6, 10, 12, 14, 18, 0]


num3 = list(filter(lambda x: x % 3 == 0, num2)) # 'x % 3 == 0' <- выбор чисел кратных трём
                                                # наличие знака равенства, выдаёт 'True' (истина)
                                                # 'x % 3' <-  выбор чисел не кратных трём
                                                # отсутствие знака равенства, выдаёт 'False' (ложь)
print(num3) # [6, 12, 18, 0], при 'x % 3 == 0' 
            # [2, 4, 10, 14], при 'x % 3'


num4 = list(filter(lambda x: 0, num1))  # "0", вместо "int(x)" перед "num", выдаст пустой список
                                        # "1" выдаст список целиком
print(num4) # [1, 2, 3, 5, 6, 7, 9, 0], при "1"
            # [], при "0"


# 01:07:00

""" Задача №47. 
Решение в группах

У вас есть код, который вы не можете менять (так часто бывает, когда код 
в глубине программы используется множество раз и вы не хотите ничего сломать):
"""
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transformed_values = list(map(transformation, values))
"""
Единственный способ вашего взаимодействия с этим кодом - посредством задания
функции transformation.
Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
список значений, а нужно получить его как есть.
Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
копией values.
"""
# Ввод:
# values = [1, 23, 42, ‘asdfg’]
# transformed_values = list(map(trasformation, values))
# if values == transformed_values:
#  print(‘ok’)
# else:
#  print(‘fail’)
       
# Вывод:
# ok

"""
Решение
"""

values = [1, 23, 42, 'asdfg']
transformed_values = list(map(lambda x: x, values)) # запись "lambda x: x", выдаёт "ok"
                                                    # запись "lambda x: 1", выдаёт "fail"
if values == transformed_values:
 print('ok') # "ok", если "lambda x: x"
else:
 print('fail')  # "fail", если "lambda x: 1"
                # В коде "Tab" заменён на "пробел", код работает,
                # читабельность кода, в данном случае, стала даже лучше.
 

# 01:15:00

"""
Задача 49. 
Решение в группах

Планеты вращаются вокруг звезд по эллиптическим орбитам. 
Назовем самой далекой планетой ту, 
орбита которой имеет самую большую площадь. 
Напишите функцию find_farthest_orbit(list_of_orbits), 
которая среди списка орбит планет найдет ту, 
по которой вращается самая далекая планета. 

Круговые орбиты не учитывайте: 
вы знаете, что у вашей звезды таких планет нет, 
зато искусственные спутники были были запущены на круговые орбиты. 
Результатом функции должен быть кортеж, содержащий длины полуосей 
эллипса орбиты самой далекой планеты. 
Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса. 
Площадь эллипса вычисляется по формуле S = pi*a*b, 
где a и b - длины полуосей эллипса. 

При решении задачи используйте списочные выражения. 
Подсказка: 
проще всего будет найти эллипс в два шага: 
сначала вычислить самую большую площадь эллипса, 
а затем найти и сам эллипс, имеющий такую площадь. 
Гарантируется, что самая далекая планета ровно одна
"""
# Ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))

# Вывод:
# 2.5 10


"""
Решение
"""

orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] # Решить с помощью генератора списков
                                                     # Прогон кортежей через генератор списков,
                                                     # где можно добавить условие (x[0] != x[1])
                                                     # if (если) x с номеном x[1], то - в список
                                                     # else (иначе), исключается из списка
find_farthest_orbit = list(map(lambda x: x, orbits)) # копия списка 'orbits'

print(*orbits) # Вывод: (1, 3) (2.5, 10) (7, 2) (6, 6) (4, 3)
print(*find_farthest_orbit) # Вывод: (1, 3) (2.5, 10) (7, 2) (6, 6) (4, 3)
                            # '*' <- вывод без квадратных скобок

print(max(orbits, key = lambda x: x[0] * x[1] * (x[0] != x[1]))) # Вывод: (2.5, 10)
                                # "x[0] * x[1]" - площадь орбиты без числа "Пи"
                                # "(x[0] != x[1])" - условие для проведения умножения 
                                # выполнение условия: "True" (истина), невыполнение: "False" (ложь)
                                # умножение на False (ложь) равноценно умножению на 0 (ноль),
                                # т.е. такой кортеж обнуляется и удаляется из списка
